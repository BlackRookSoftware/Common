package com.blackrook.commons;

import java.lang.reflect.Array;
import java.util.Arrays;

import com.blackrook.commons.hash.HashMap;
import com.blackrook.commons.list.List;

/**
 * A trie is a data structure that maps an object to another object, using a path
 * of objects derived from the key. This is best used 
 * @author Matthew Tropiano
 * @param <V> the value type corresponding to keys.
 */
public abstract class AbstractTrie<K extends Object, S extends Object, V extends Object> implements Sizable
{
	/** Root Node. */
	private Node<K, S, V> root;
	/** Current size. */
	private int size;

	/**
	 * Creates a new trie.
	 */
	public AbstractTrie()
	{
		root = new Node<K, S, V>();
		size = 0;
	}

	/**
	 * Creates the segments necessary to find/store keys and values.
	 * This should always create the same segments for the same key.
	 * @param key the key to generate significant segments for.
	 * @return the list of segments for the key.
	 */
	protected abstract S[] getSegments(K key);

	/**
	 * Returns a value for the key provided.
	 * @param key the key.
	 * @return the corresponding value, or null if there is no value associated with that key.
	 */
	public V get(K key)
	{
		Result<S, V> out = getPartial(key);
		return out.getRemainderIndex() != out.getSegments().length ? out.value : null;
	}

	/**
	 * Returns a value for the key provided, but returns the last eligible object in the path.
	 * Remainders equaling the length of the key means that the search reached the end of the key.
	 * @param key the key.
	 * @return a trie {@link Result}. The value on the result can be null 
	 * if the end was reached without finding anything along the way.
	 */
	public Result<S, V> getPartial(K key)
	{
		S[] segments = getSegments(key);
		int segindex = 0;
		int out = 0;
		
		Node<K, S, V> current = root;
		Node<K, S, V> lastEligible = current.value != null ? current : null;
		while (segindex < segments.length && current != null && current.hasEdges())
		{
			current = current.getEdge(segments[segindex]);
			if (current != null && current.value != null)
			{
				lastEligible = current;
				out = segindex + 1;
			}
			segindex++;
		}
		
		if (lastEligible == null)
			return new Result<S, V>(null, segments, -1);
		return new Result<S, V>(lastEligible.value, segments, out);
	}

	/**
	 * Returns all possible keys that can be used based on an input key.
	 */
	@SuppressWarnings("unchecked")
	public K[] getPossibleKeys(K startingKey)
	{
		S[] segments = getSegments(startingKey);
		int segindex = 0;
		
		Node<K, S, V> current = root;
		Node<K, S, V> lastEligible = current;
		while (segindex < segments.length && current != null && current.hasEdges())
		{
			current = current.getEdge(segments[segindex]);
			if (current != null && current.value != null)
				lastEligible = current;
			segindex++;
		}
		
		List<K> accum = new List<K>();
		getPossibleKeysRecurse(lastEligible, accum);
		K[] out = (K[])Array.newInstance(startingKey.getClass(), accum.size());
		accum.toArray(out);
		return out;
	}
	
	/**
	 * Returns all possible keys that can be used based on an input key.
	 */
	private void getPossibleKeysRecurse(Node<K, S, V> start, List<K> accum)
	{
		if (start.getKey() != null)
			accum.add(start.getKey());
		
		for (ObjectPair<S, Node<K,S,V>> pair : start.edgeMap)
			getPossibleKeysRecurse(pair.getValue(), accum);
	}
	
	/**
	 * Adds a value to this trie with a particular key.
	 * If the association exists, the value is replaced.
	 * @param key the key to use.
	 * @param value the corresponding value.
	 * @throws IllegalArgumentException if value is null.
	 */
	public void put(K key, V value)
	{
		if (value == null)
			throw new IllegalArgumentException("Value cannot be null.");
		
		S[] segments = getSegments(key);
		int segindex = 0;
		
		Node<K, S, V> current = root;
		Node<K, S, V> next = null;
		while (segindex < segments.length)
		{
			if ((next = current.getEdge(segments[segindex])) == null)
			{
				next = new Node<K, S, V>();
				current.putEdge(segments[segindex], next);
			}
			current = next;
			segindex++;
		}
		
		V prevval = current.value;
		current.key = key;
		current.value = value;
		if (prevval == null)
			size++;
	}

	@Override
	public int size()
	{
		return size;
	}

	@Override
	public boolean isEmpty()
	{
		return size() == 0;
	}
	
	/**
	 * A result of a passive search on a trie.
	 */
	public static class Result<S, V>
	{
		private V value;
		private S[] segments;
		private int remainderIndex;
		
		Result(V value, S[] segments, int hops)
		{
			this.value = value;
			this.segments = segments;
			this.remainderIndex = hops;
		}
		
		/**
		 * Returns the value on the result.
		 */
		public V getValue() 
		{
			return value;
		}
		
		/**
		 * Returns the segments generated by the key.
		 */
		public S[] getSegments()
		{
			return segments;
		}
		
		/**
		 * Returns how many edge hops that this performed in order to reach the result.
		 * This index is the "remainder" of the unused segments.
		 */
		public int getRemainderIndex() 
		{
			return remainderIndex;
		}
		
		@Override
		public String toString()
		{
			return value + ": " + Arrays.toString(segments) + " " + remainderIndex;
		}
		
	}

	/**
	 * A single node in the Trie.
	 */
	protected static class Node<K, S, V>
	{
		/** Edge map. */
		private AbstractMap<S, Node<K, S, V>> edgeMap;
		/** Key used to store this value. */
		private K key;
		/** Value stored at this node. Can be null. */
		private V value;
		
		protected Node()
		{
			edgeMap = new HashMap<S, Node<K, S, V>>(2, 1f);
			key = null;
			value = null;
		}
		
		/**
		 * Returns an edge for a segment, or null for no matching segment.
		 */
		public Node<K, S, V> getEdge(S segment)
		{
			return edgeMap.get(segment);
		}
		
		/**
		 * Returns an edge for a segment, or null for no matching segment.
		 */
		public void putEdge(S segment, Node<K, S, V> node)
		{
			edgeMap.put(segment, node);
		}
		
		/**
		 * Returns the key used to first store this value.
		 */
		public K getKey()
		{
			return key;
		}
		
		/**
		 * Gets the value on this node. Can be null.
		 */
		public V getValue()
		{
			return value;
		}
		
		/**
		 * Sets the value on this node.
		 */
		public void setValue(V value)
		{
			this.value = value;
		}
		
		/**
		 * Returns if this node can be cleaned up.
		 */
		public boolean isExpired()
		{
			return edgeMap.isEmpty() && value == null;
		}
		
		/**
		 * Returns if the node has possible paths.
		 */
		public boolean hasEdges()
		{
			return !edgeMap.isEmpty();
		}
		
	}

}


